'''


오늘 이분탐색 졸업식...

1654 랜선자르기에 이어서


'''







# A = [[0] * (N + 1) for _ in range(N + 1)]
#
# B = [0]
#
#
# for row in range(N + 1):
#     for col in range(N + 1):
#
#         if row == 0 or col == 0:
#             continue
#         A[row][col] = row * col
#         B.append(row*col)
#
# # 여기서 이분탐색으로 정렬을 하라는 건가?!
# B.sort()
#
# print(B[K])


# 와 이분탐색인거 알고 봐도 위처럼 푸네 메모리랑 시간을 봐라!! 위에처럼 하면 되겠니?!

'''

우리는 이분 탐색으로 어떤 수보다 작은 자연수의 곱(i * j)이 몇 개인지 알아낼 것이다.

A보다 작은 숫자가 몇개인지 찾아내면 A가 몇 번째 숫자인지 알 수 있다.(너무나 당연)

예를 들어 10 * 10에서 20보다 작거나 같은 수를 생각해보자.

1*1 ~ 1*10 

2*1 ~ 2*10

3*1 ~ 3*6   

4*1 ~ 4*5

5*1 ~ 5*4

6*1 ~ 6*3

7*1 ~ 7*2

8*1 ~ 8*2

9*1 ~ 9*2

10*1 ~ 10*2

위 수가 존재할텐데, 이는 반대로 생각해보면 20을 행번호(10자리의 숫자)로 나눈 몫이다.



20//1: 10개 --> 단 열의 숫자(N*N배열이므로)를 초과할 수 없다.

20//2: 10개

20//3: 6개

.

.

.

20//10: 2개

따라서 이를 식으로 표기해보면 아래와 같다.

temp = 0

for i in range(1, N+1):
        temp += min(mid//i, N)

 

이렇게 해당 숫자(mid)보다 작거나 같은 숫자들을 전부 찾아줌으로써 mid가 몇번째에 위치한 숫자인지 알아낼 수 있다.

이를 이분탐색으로 진행한다.

https://claude-u.tistory.com/449



'''

N = int(input())

K = int(input())

left = 1 # 1번 인덱스부터
right = N * N# 도달할 수 있는 가장 마지막 인덱스

#이분탐색 시작

while left <= right :

    # 이분 탐색을 위한 중앙값 계산
    mid = (left + right) // 2

    # 몇번 쨰 인덱스에 위치?! 한 값을 결정하기 위한 임시 변수
    temp = 0
    #행번호로 나누기 => "행번호로 나눈 몫"이지만 그 값이 열의 갯수(N)을 초과할 수는 없다.
    for i in range(1, N + 1):
        temp += min(mid // i, N)

    # 찾고자 하는 인덱스에 도달했으면 답, 그 보다 크면, 탐색의 오른쪽 범위를 줄여, 더 작은 범위에서 탐색이 될 수 있도록
    if temp >= K:
        answer = mid
        right = mid - 1

    # 찾고자 하는 인덱스 보다 값이 더 작다면, 탐색의 왼쪽 범위를 키워, 더 큰 범위에서 탐색이 될 수 있도록
    else:
        left = mid + 1

print(answer)




